# Read alignment in the field

真正在测序中使用的工具，其实就是index和动态规划算法的结合。

![image-20220102191154136](https://gitee.com/joy_thestraydog/typora1.0/raw/master/image-20220102191154136.png)

### index

首先，index让我们找到能与query序列匹配的一小撮基因组的位置，这些位置上的序列与query共享一些子序列。

![image-20220102191452327](https://gitee.com/joy_thestraydog/typora1.0/raw/master/image-20220102191452327.png)

index环节有点像是筛选过程，把我们的目标位置从整个基因组缩小到具体的一些位置。

![image-20220102191555403](https://gitee.com/joy_thestraydog/typora1.0/raw/master/image-20220102191555403.png)

如果缺少index这一步，我们当然可以直接使用动态规划算法，但是我们需要填写的矩阵将会非常巨大

![image-20220102191720132](https://gitee.com/joy_thestraydog/typora1.0/raw/master/image-20220102191720132.png)

### dynamic programming

我们在index之后依然需要动态规划算法的原因是，index对于替换和indel的处理并不精细，它仅仅对于exact matching比较在行。而动态规划算法非常灵活，善于处理indel问题。

![image-20220102192115501](https://gitee.com/joy_thestraydog/typora1.0/raw/master/image-20220102192115501.png)

总的来说，index善于快速缩小我们的verification范围，但不善于解决错配和indel；

动态规划算法非常善于灵活解决indel问题，但计算量大速度慢

# Assembly

## working from scratch

assembly，全名：de novo shotgun assembly。就是在没有参考基因组的情况下对DNA片段进行组装。这比我们之前直接把序列比对到参考基因组上面要困难得多。

## First and second laws of assembly

组装的过程是把蓝色的DNA片段组装成下面红色的序列

![image-20220102193304296](https://gitee.com/joy_thestraydog/typora1.0/raw/master/image-20220102193304296.png)

但实际的组装过程比示意图要艰难，因为我们不知道这些蓝色序列到底来自哪里，下面这个更加形象

![image-20220102193357800](https://gitee.com/joy_thestraydog/typora1.0/raw/master/image-20220102193357800.png)

### coverage

coverage(测序深度)指的是一个碱基被覆盖了多少次，如图，蓝色的C被覆盖了5次，那么我们可以说这个位置的coverage=5。换句话说，如果我们想知道这个蓝C来自基因组的哪个区域，这5条序列就给了我们独立的5条证据证明这个位置是C。

![image-20220102193547487](https://gitee.com/joy_thestraydog/typora1.0/raw/master/image-20220102193547487.png)

但情况并不往往这么乐观，有时候这些证据之间无法达成统一，如

![image-20220102193836008](https://gitee.com/joy_thestraydog/typora1.0/raw/master/image-20220102193836008.png)

以上是特定位置coverage的定义。

overall coverage就是所有位置的平均coverage，计算方法是所有reads的长度除以组装起来的基因的长度。

![image-20220102194851917](https://gitee.com/joy_thestraydog/typora1.0/raw/master/image-20220102194851917.png)

### First law of assembly

首先我们看来自同一个基因组的两条序列，我们很快可以发现，一条序列的后缀与另一条序列的前缀非常相似

![image-20220102195006125](https://gitee.com/joy_thestraydog/typora1.0/raw/master/image-20220102195006125.png)

这给了我们一个提示：这两条序列可能来自同一位置的overlapping部分。这就是组装的第一条规则

![image-20220102195210020](https://gitee.com/joy_thestraydog/typora1.0/raw/master/image-20220102195210020.png)

我们发现，定律中容忍一些错配。原因是：1. 测序误差 2. 多倍体(例如人类有两条序列，分别来自父母)

### Second law of assembly

更多的覆盖度会导致更长的overlap

![image-20220102195809030](https://gitee.com/joy_thestraydog/typora1.0/raw/master/image-20220102195809030.png)

例如图中圈出的片段

![image-20220102195947050](https://gitee.com/joy_thestraydog/typora1.0/raw/master/image-20220102195947050.png)

# Overlap graphs

在有向图(directed graph)中，nodes 和 edge分别有不同含义，node一般代表目标，edge一般代表两个目标之间的关系。

我们用有向图表示两个DNA序列之间的overlap的时候，用node表示序列本身，用edge代表重叠关系：由suffix 指向prefix

![image-20220103160234439](https://gitee.com/joy_thestraydog/typora1.0/raw/master/image-20220103160234439.png)

下面是一个来自DNA序列片段的overlap graph的例子。

node中是被分割成5-mer的子串，edge上的是互相重叠的字符数量。

我们把exact match的个数大于等于4的序列筛选出来，因为有一些较少的overlap非常可能是随机产生的，我们不希望有太多干扰项从而影响组装效率。

![image-20220103170725509](https://gitee.com/joy_thestraydog/typora1.0/raw/master/image-20220103170725509.png)

再仔细观察可以发现，图中标红的是一段特殊的路径：是按照上面那段长序列拼接的路径

![image-20220103171253287](https://gitee.com/joy_thestraydog/typora1.0/raw/master/image-20220103171253287.png)

但是事实上现实情况并没有这么理想，会有一些错配等等。